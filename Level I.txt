Q1

чем, на ваш взгляд, отличается хорошее клиентское приложение от
плохого с точки зрения

 пользователя;

продуманность интерфейса - доступ к основному функционалу должен быть быстрым
желательно чтобы было два режима интерфейса - упрощенный и подробный
должен быть контроль над поведением приложения. пример плохого приложения - skype в нем нельзя настраивать некоторые важные параметры отображения(например убрать смайлы) и поведения приложения. хорошее приложение должно предвидеть поведение пользователя и предоставлять дополнительные функции которые делают полезность приложения и удобство работы очень высокими

 менеджера проекта
должна быть продумана поддержка приложения. например если возникают баги - сделать форму обратной связи в кот указать что сломалось и какие действия были выполнены пользователем. это упростит поддержку приложения. заранее должен быть отлажен процесс разработки приложения, все участники(дизайнер верстальщик, программист) должны знать точно что от них требуется сделать

 дизайнера
дизайн должен быть ненавязчивым. не кричащим. не должен содержать декоративные элементы которые вредят юзабилити

 верстальщика
интерфейс должен быть сверстан по правилам и стандартам верстки которые обеспечивают беспроблемную длительную поддержку верстки. чтобы можно было без проблем добавлять новое и обновлять старое. в компаниях которые имеют опыт разработки такие стандарты разработки существуют и они обязательны

 серверного программиста
протокол должен быть хорошо продуман в плане futureproof чтобы можно было совмещать сжатие данных с гибкостью настройки протокола. например restful решает проблему кеширования данных при высоких нагрузках. graphql решает проблему гибкости протокола и underfetching и overfetching. можно использовать разные решения для разных задач. часть АПИ можно сделать используя один подход часть другой. это актуально при больших нагрузках на сервер где важно все оптимизировать


Q2
архитектура изначально должна быть модульной чтобы обеспечить минимум futureproof. каждый модуль должен быть независимым чтобы его можно было спокойно обновлять или заменять или удалить. в некоторых случаях можно использовать готовый популярный движок и написав к нему плагин. это значительно ускорит разработку и улучшит поддерживаемость (у популярного активно развивающегося движка много юзеров и многие проблемы решены). также можно использовать фреймворки придерживаясь  тойже политики, если проект сложный(содержит множество деталей). конкретно мой опыт:
этот проект был сделан путем написания плагинов к отличному движку для досок объявления osclass
https://sites.google.com/site/softwaredeveloperportfolio2008/projects/1000000stores-ru

Q3
Container компоненты содержат работу с состоянием и бизнес логику Presentation компоненты содержат отображение внешнего вида и ничего более. Однако это не всегда так бывают исключения. Насчет плюсов и минусов - считается что это устарело тк код усложняется и различать тип компонента не обязательно:
https://stackoverflow.com/questions/57427048/hooks-equivalent-of-container-components-in-react-redux
насчет грамотного построения приложения:
https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0
если приложение очень простое не имеет смысла тратить время на разделение этих двух концепции тк проще потом если оно усложнится просто исправить код

Q4
https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/Inheritance
я не делаю велосипеды, вразы продуктивнее и быстрее изучить существующий опыт особенно если это опыт сообщества а не пары человек.

Q5
можно использовать то самое лучшее что есть у сообщества однако конкретный выбор зависит от конкретной задачи и условий(стандартов) разработки. не существует "серебрянной пули"
касаемо написания тестов вообще - лично я никогда их не писал и мне удалось написать минимум два сложных проекта - Tutorion и Любимая Семья. код в моем репозитории. я использую паттерны проектирования и создаю код модульно так чтобы модули были изолированы друг от друга а внутри модуля простейший код который написан так что не допускает возникновение человеческого фактора. но я также понимаю зачем использовать тесты может быть необходимо и готов к этой необходимости.

Q6
понять структуру данных и прочие отношения в данных и исходя из них сделать логику. например если если в риэлторском приложении выбрать тип сделки "аренда" то поле "стоимость объекта" следует либо убрать либо изменить название на "цена в месяц"

Q7
у меня мало опыта разработки на js поэтому инструментов нет. когда разрабатывал на ActionScript3 делал себе инструменты сам.

Q8
habr.com
google.com
я либо читаю статью на habr либо ищу в сети, на английском языке, статьи и читаю несколько шутк по одному вопросу. я не читаю никакие периодические новостные издания. вместо этого я вручную проверяю на устаревание все технологии с которыми работаю.

>> Какие ещё области знаний, кроме тех, что непосредственно относятся к работе, вам
интересны?

все что связано с искуственным интеллектом. только не бред который сейчас делают с помощью нейросетей и машинного обучения. несмотря на отличные результаты это всего лишь копирование того что уже есть это всего лишь видимость. мне интересны процессы мышления, то как работают мысли внимание чувства эмоции итд. я изучаю буддизм. у меня есть собственные разработки без нейросетей, на базе моих наблюдений процессов мышления в моем уме. меня интересует искуственная жизнь. как создать жизнь. что такое "живое"? итд
еще я сделал собственный 3D движок без знаний высшей математики(при рассчетах используется операции над 2D вектором). код движка могу показать он очень короткий а принцип простейший для понимания. придумал за 1-5 минут сидя на кухне. реализовал может быть за пол часа. без всяких сложных матриц всяких проекций итд прочих вещей которые нереально понять быстро и просто.

Q9
сейчас я ищу постоянную стабильную работу с возможностью развиваться как специалист. вариант с фрилансом меня больше не устраивает.
одна из моих последних работ - телеграм бот для чата копирайтеров nodejs. код в моем репозитории https://github.com/asamir2007.

прошу вас действительно посмотреть на мой код проекта Tutorion. я использовал эту архитектуру в последущих проектах без изменений причем эти проекты собирал копируя модули из старых. высокое качество моего кода признали коллеги один из которых является доктором наук(чтото по лазерам) Алексей Соколов когда я работал над Tutorion. основа архитектуры - агенты сообщения и среды содержащие агентов. среда содержит данные и прочие адаптированные сервисы с которыми работает приложение. агенты работают внутри сред реагируют на сообщения посылают сообщения выполняют операции над данными. можно делать иерархию агентов а также отдельную среду приложения для тестироания и процесса запуска. мне очень понравилась концепция мультиагентных систем и она отлично показала себя на практике в нескольких проектах. до этой концепции я использовал PureMVC три паттерна фасад вид контроль модель. концепция проста для понимания. если честно то что сейчас происходит в веб разработке и в частности в React я с читаю overbloated. все можно сделать вразы проще и универсальнее. простота кода позволяет удешивить процесс разработки тк не нужно искать специалистов. моя ахритектура универсальна ее можно использовать и в клиенте и на сервере. написал restful php бэкенд когда переносил ее на php.